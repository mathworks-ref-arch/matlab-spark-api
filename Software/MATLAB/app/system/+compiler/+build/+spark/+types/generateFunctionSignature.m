function jsonFileName = generateFunctionSignature(funcName, IN, OUT)
    % generateFunctionSignature Helper function to get function signature
    %
    % This function creates a JSON file that provides the SparkBuildercan
    % with additional information when compiling functions that should run
    % on Spark clusters.
    %
    % The function takes two or three arguments:
    %   funcName - The name of the function (without .m ending) this
    %              signature is for
    %   IN       - A cell array of arguments for the function
    %   OUT      - A cell array of return values for the function
    %
    % It will automatically create a JSON file in the same location as the
    % function, but with the ending "_signature.json" instead of ".m".
    % The function also returns the name of the JSON file, but this can
    % mostly be ignored.
    %
    % Examples:
    %  % Importing the function, to make examples shorter
    %  import compiler.build.spark.types.generateFunctionSignature
    %
    % A function that takes 3 scalar double values, and returns two
    % double scalars:
    %  generateFunctionSignature('simplecalc', {3, 4, 5}, {1, 2})
    %
    % The same signature can be generated by simply omitting the output
    % values. In this case, the function will simply call the actual
    % function with the input values provided, and use the results of this
    % as the OUT argument.
    %  generateFunctionSignature('simplecalc', {3, 4, 5})
    %
    % A function that takes a table and a scalar, and returns another table
    %  generateFunctionSignature('gaussianFilter', {T_in, 4})

    % Copyright 2022 The MathWorks, Inc.


    jsonFileName = compiler.build.spark.internal.getJSONName(funcName);

    % If no OUT argument was given, try generating this
    if nargin < 3
        nOut = nargout(funcName);
        OUT = cell(1,nOut);
        [OUT{1:nOut}] = feval(funcName, IN{:});
    end
   
    [inArgNames, outArgNames] = compiler.build.spark.internal.getArgNames(which(funcName));
    nIn = nargin(funcName);
    nOut = nargout(funcName);
    if isempty(inArgNames) && nIn > 0
        inArgNames = "in_" + (1:obj.nArgIn);
    end
    if isempty(outArgNames) && nOut > 0
        outArgNames = "out_" + (1:obj.nArgOut);
    end
    enc = compiler.build.spark.types.getTypeEncoding(IN, OUT, inArgNames, outArgNames);

    fh = fopen(jsonFileName, "w");
    if fh < 0
        error("Couldn't open file '%s' for writing.\n", jsonFileName);
    end
    fprintf(fh, '%s\n', enc);
    fclose(fh);

    if nargout == 0
        fprintf("Generated function signature:\n\t%s\n", jsonFileName);
        clear('jsonFileName');
    end

end


